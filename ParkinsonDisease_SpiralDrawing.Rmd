---
title: "Predicting Parkinson's disease diagnostic with digital handwriting tests"
author: "Nina Caparros"
date: "`r Sys.Date()`"
documentclass: "article"
output: 
  pdf_document:
    number_sections: true
---

\renewcommand\thesubsection{\Roman{subsection}}
\renewcommand\thesubsubsection{\Alph{subsubsection}}

\newpage
\tableofcontents
\newpage

```{r load_libraries, include=FALSE}
if(!require(dplyr)) install.packages("dplyr", repos = "http://cran.us.r-project.org")
if(!require(ids)) install.packages("ids", repos = "http://cran.us.r-project.org")
if(!require(tidyr)) install.packages("tidyr", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(anytime)) install.packages("anytime", repos = "http://cran.us.r-project.org")
if(!require(ggplot2)) install.packages("ggplot2", repos = "http://cran.us.r-project.org")
if(!require(geiger)) install.packages("geiger", repos = "http://cran.us.r-project.org")
if(!require(ggpubr)) install.packages("ggpubr", repos = "http://cran.us.r-project.org")
if(!require(lubridate)) install.packages("lubridate", repos = "http://cran.us.r-project.org")
if(!require(ggarrange)) install.packages("ggarrange", repos = "http://cran.us.r-project.org")
if(!require(sp)) install.packages("sp", repos = "http://cran.us.r-project.org")
if(!require(rgeos)) install.packages("rgeos", repos = "http://cran.us.r-project.org")
if(!require(randomForest)) install.packages("randomForest", repos = "http://cran.us.r-project.org")
if(!require(knitr)) install.packages("knitr", repos = "http://cran.us.r-project.org")
```


# Introduction

This report presented the analysis and results of the "Choose Your Own Project" from the HarvardX's ninth course of the Data Science Professional Certificate Program available on edx.org. The chosen thematic wass the prediction of the Parkinson's disease diagnosis depending on the results of three tests, measuring the motor performance, the tremor and the hand stability.

## Nota bene

The following section was a quick presentation of the Parkinson's disease but was not mandatory to understand this report.

When not relevant, the code used to create this report is run but not displayed. The complete source code can be found on GitHub (https://github.com/ncaparros/ParkinsonDisease_SpiralDrawing).

## Parkinson's disease

Parkinson's disease, sometimes abreviated to PD, is a long-term neurodegenerative disorder. Its cause is unknown, though it is believed to involve genetic (as relatives tend to contract the disease), and/or environmental factors (as pesticides). 

The disease affects mostly the motor system, as tremor, akinesia*, shaking, rigidity, slowness of movement, difficulty with walking,... and as it worsen it can cause depression, anxiety (more than a third of people with Parkinson's disease), emotional and sleep troubles, and in the advanced stages the disease can lead to dementia.

The motor symptoms of the Parkinson's disease (parkinsonian syndrome) are caused by the death of cells, more precisely dopaminergic* neurons, in the *substantia nigra* (a region of the midbrain, see Figure 2). The *substantia nigra* is a basal ganglia* divided into to parts : the *pars reticula* and the *pars compacta* (see Figure 1). It is the part of the brain that plays an important role in reward-seeking, learning and movement. 

Dopamine is an organic chemical functioning as both an hormone and a neurotransmitter. Basically, neurotransmitters are chemical messengers which transmit signals by being released from one neuron to a receptor on the target cells. Neurotransmitters are critical to execute everyday functions as, in our case, movement (contact between a motor neuron  and a muscle fiber).

The lack of dopamine (due to the death of those cells, and therefore induces a smaller substancia nigra than on a healthy subject, see Figure 1) provokes emotional troubles as said previously, and since the downsized *substancia nigra* is connected to the motor cortex (via the *pars reticula*, see Figure 1), it causes the parkisonian syndromes.

The Figure 1 (left) shows a lateral cross-section of a brain. The red arrows represent the dopamine's exchanges between the *pars reticula*. The Figure 1 (right) shows the lack of dopaminergic neurons in a brain of a person affected by Parkinson's disease compared to a healthy brain.

```{r, echo=FALSE,out.width="49%", out.height="20%",fig.cap="Lateral cross-section of the brain (left, source : http://www.neuroconvention.com/),// *Substancia nigra* differences between a healthy brain and a Parkinson's brain (right, source : https://scienceofparkinsons.com/) ",fig.show='hold',fig.align='center'}
knitr::include_graphics(c("img/brain_pd.jpg","img/sn.jpg"))
``` 


Parkinson's disease affected 6.2 million people in 2015 and resulted in more than 117,000 deaths. This condition mostly occurs in people over the age of 60 (about one percent are affected). The average life expectancy following diagnosis is between 7 and 15 years.

## Project overview

In 2011, the Department of Neurology in Cerrahpasa Faculty of Medicine in Istanbul University (Turkey) provided a data set  of test results from 62 patients with the Parkinson's disease and 15 from healthy people for a study (Muhammed Erdem Isenkul, Betul Erdogdu Sakar and Olcay Kursun) which purpose was to monitor Parkinson's disease with digitized graphics tablet. The goal of this study was to provide easy access to Parkinson's disease progress monitoring to the elderly patients, or patients with an advanced stage of the disease, instead of the inconvenient and time-consuming process at the clinic. The tests aim to be non-invasive, would not require brain scans, would ease the work of the medical doctors, and would not require trained medical staff assigned to this task. 

### Material

It was decided to perform three handwriting tests on a graphic tablet (Wacom Cintiq 12WX graphics, see Figure 3). The tablet would measure several parameters as : the coordinates (x-y-z) of the pen on the table, the pressure over the screen, the grip angle on the pen at regular time intervals. A software was developped in order to test the coordination of the patient.

![Wacom Cintiq 12WX graphics, source : https://www.bhphotovideo.com/](img/wacom.jpg){width=50%}

### Tests 

The three tests performed by the patients were :

* **Static Spiral Test (SST)** is a traditionnal test usually performed with paper and pencil. An Archimedean spiral (see following plot) is printed on it, and the patient needs to retrace it. The more the patient suffer from an advanced stage of the Parkinson's disease, the more differences between the archimedean spiral and his drawing.

* **Dynamic Spiral Test (DST)** is a new test introduced in the study, where the archimedean spiral *blinks*. It is only seen at certain times. It becomes more difficult to follow the spiral.

* **Stability On Certain Point Test (SOCPT)** is a test where there is a red point in the middle of the tablet's screen, and the patients are asked to hold the pen on the point without touching the screen. This test determine the patient's hand stability and hand tremor level.

### Archimedean spiral

The Archimedean spiral (named after the Greek mathematician Archimedes), can be described by the polar coordinates equation :

$$r = a + b\theta$$
With $r$ the radius, $a$ real number turning the spiral, $b$ real number controling the distance between successive turnings, and $\theta$ the angle velocity. 
The spiral \begin{quote} is the locus of points corresponding to the locations over time of a point moving away from a fixed point with constant speed along a line that rotates with constant angular velocity.
\end{quote}

It can be described in the cartesian coordinates by :
$$ x = (a+bt)*cos(t)$$
$$ y = (a+bt)*sin(t)$$

```{r archimedean spiral, echo=FALSE, fig.align="center", fig.cap="Archimedean spiral"}
 b <- 11.5
 t <- seq(0,6*pi, length.out=500)
 
 x <- b*t * (cos(t))
 y <- b*t * - (sin(t))
 
 archimedeanSpiral = data.frame(x,y)
 
 ggplot() + 
   geom_path(aes(x,y), color="red")
```

### Goal 

In this report I will try to build an algorithm able to predict if the patient has or has not Parkinson's disease based on this dataset. I do not have access to the software used in the study, so I will have to recreate and approximate the Archimedean spiral. I do not have access to the *scores* of the patients, given by neurologists, representing the stage of Parkinson's disease. Therefore, my output will only be a boolean, has, or has not, with at best a percentage of probability, not a neurological scale. If efficient, these results would help determine if a person taking the test should consult a specialist for further examination. The original study based its conclusion of the acceleration (change of velocity) for the firsts two tests (static and dynamic spiral tests). I will try instead to use the areas and lengths of each drawing, as well as the difference of time needed to perform the two firsts tests.  

## Dataset overview

The dataset provided was an archive .zip containing three folders. One of them was composed by only .png images of the tests results, which were already saved in the text dataset. In the two remaining folders, there were datasets related to healthy (called controls) and people with Parkinson's disease (called PWP, People With Parkinson). Since the datasets in both folders were following the same pattern, they were merged in a single one.

Each text file of the dataset was the test results of a single patient. Each line of the file represented one measure, at a certain time, of the X-Y-Z coordinates of the digital pen, the pressure of the pen on the screen, the grip angle, the timestamp (at which the measure had been taken) and the test identifier (Static Spiral Test : 0, Dynamic Spiral Test : 1, Stability Test on Certain Point :2).

```{r extracting datas and building data frame, include=FALSE}
#Function to extract the dataframe from either the data in the repository (local, from GitHub) or from the UCI website
createDf <- function(){
  
  #File path to the directory containing the datas of the healthy people (controls)
  filePathCtrl = "data/hw_dataset/control/"
  
  #Getting the name of all the files in the directory in order to load the datas
  fileNamesCtrl <- list.files(path = filePathCtrl)
  
  #Reading the data for all the control files
  controls <- do.call(rbind, lapply(fileNamesCtrl, function(x) {
    
    #generate a random id for the patient
    randID <- proquint_to_int(proquint(), as = "numeric")
    
    #add id and isPwp as column
    t <- cbind(read.table( file = paste(filePathCtrl,
                                        x, 
                                        sep="")), 
               patientID = randID, 
               isPwp = FALSE)
  }))
  
  #File path to the directory containing the datas of the people with Parkinson (PWP)
  filePathPwp = "data/hw_dataset/parkinson/"
  
  #Getting the name of all the files in the directory in order to load the datas
  fileNamesPwp <- list.files(path = filePathPwp)
  
  #Reading the data for all the Parkinson files
  pwp <- do.call(rbind, lapply(fileNamesPwp, function(x) {
    
    #generate a random id for the patient
    randID <- proquint_to_int(proquint(), as = "numeric")
    
    #add id and isPwp as column
    t <- cbind(read.table( file = paste(filePathPwp,
                                        x, 
                                        sep="")), 
               patientID = randID, 
               isPwp = TRUE)
  }))
  
  #merge controls and pwp df into a single data.frame
  df <- rbind(controls, pwp)
  
  return(df)
}


if(dir.exists("data")){
  #First case : the data already exists on the working directory

  df <- createDf()
  
} else {
    #Second case : the data does not exist on the working directory
    
    #Names for : the created temporary directory, the directory we need to move, main the directory
    dirpath = "data"
    dirToMove = "new_dataset/parkinson"
    dirToKeep = "hw_dataset/parkinson"
    
    #download the .zip containing the datasets from UCI
    dl <- tempfile()
    download.file("https://archive.ics.uci.edu/ml/machine-learning-databases/00395/PARKINSON_HW.zip", dl)
    
    #unziping the archive
    unzip(dl, exdir="data")
    
    #Copy the files from the new_dataset/parkinson into the main directory hw_dataset/parkinson
    sapply(c(list.files(paste0(dirpath,"/",dirToMove))), function(file){
      file.copy(paste0(dirpath,"/",dirToMove,"/",file), dirToKeep)
    })
    
    #building the data frame df
    df <- createDf()
    
    #Removing the temporary directory
    unlink(dirpath, recursive = TRUE)
}

```


The data was presented as *X;Y;Z;Pressure;GripAngle;Timestamp;TestID*:

>191;205;0;39;1350;17535179;0

>191;205;0;54;1360;17535186;0

>191;205;0;60;1350;17535193;0

>191;205;0;61;1360;17535200;0

# Method and analysis

In this section I described the process, from analysing the original dataset, to building the prediction algorithms, through data cleaning and analysis.

## Initial Data

Once the data downloaded and the data frame built (see previous section), the first step was to add a random identifier to each patient and to note if he has Parkinson's disease or not. The random identifier had been chosen because :
* since the text files were from different folders, and as some files had the same numbers, no pattern could be used for identifiers.
* it allowed to not get focused on the patient id.

```{r patientID and isPWP, echo=FALSE,results='asis' }
kable(head(df))
```

Then, each value had to be extracted into a new column of the data frame.

```{r extracting data, echo=FALSE}
#Extracting values into columns
df <- df %>% 
  separate(V1, c("X", "Y", "Z", "Pressure", "GripAngle","Timestamp", "TestID"),";")

kable(head(df))
```

X and Y represents the place of the pen on the tablet, we can assume horizontally and vertically, and Z is the height between the pen and the screen. A Z equal to 0 means the pen is on the screen.

A new data frame containing one line by patient was then created and filled as :

```{r extracting patients, echo=FALSE}
#Getting every patient in a dataframe 'patients'
patients <- df %>% 
  select(patientID, isPwp) %>% 
  distinct(patientID)

kable(head(patients))
```

It will be used for summaries and additionnal informations on the patient or the test later.

## Data cleaning

In this subsection I explained the process of formating the values, cleaning the Timestamp column and calibrating the test samples.

### Format

Since the datas were extracted from a text file, they were all, but the two we added, of class character.

```{r column classes}
lapply(df,class)
```

It was impossible then to perform any action on those values, so they were all converted as numeric with the `as.numeric` function.

```{r text values as numeric, include=FALSE}
#Converting string values into numeric values
df <- df %>% mutate(X = as.numeric(X),
                    Y = as.numeric(Y),
                    Z = as.numeric(Z),
                    Pressure = as.numeric(Pressure),
                    GripAngle = as.numeric(GripAngle),
                    Timestamp = as.numeric(Timestamp))
```

### Cleaning TimeStamp

The timestamp columns seemed pretty obscur, and trying to parse it into a readable date would do produce either an impossible date (`make_date` or  `make_datetime`) or NA values (`dym`, `mdy_hms`, `as.Date`,...).

```{r trying to parse timestamp}
make_date(as.character(df[1,]$Timestamp))
make_datetime(df[1,]$Timestamp)
dym(as.character(df[1,]$Timestamp))
as.Date(as.character(df[1,]$Timestamp), "%Y%M%D")
```

To be able to use the timestamp more easily, and mostly because we do not know its unit (probably milliseconds but we cannot know for sure), I substracted the first timestamp of every couple test/patient to all the timestamp values, making the first value 0. To do this I had to create a new empty data frame, and two for loops : one for the test (0 to 2) and one for the patients (0 to `nrow(patients)`). Inside the loops, I would get the values of the current patient for the current test, arranged by ascending timestamp, and the first value would be the initial timestamp value. Then, every timestamp would be mutated as $timestamp_i = timestamp_i - timestamp_0$. The mutated data frame would then be merge (`rbind`) into the final data frame.

```{r cleaning timestamp, echo=FALSE}
kable(head(df))

#create a new dataframe into which convert the timestamp values into more readable and interpretable values
completeDf <- data.frame()

#For each of the tests "test"
for(test in seq(0, by=1, length=3)){
  
  #For each of the patients "indPatient"
  for(indPatient in seq(1, by=1, length=nrow(patients))){
    
    #Create a temporary data frame for patient "indPatient" 
    #and test "test"
    temp_df <- df %>% 
      filter(TestID == test & 
               patientID == patients[indPatient,]$patientID) %>% 
      arrange(Timestamp)
    
    #Get first value of timestamp
    initialTimestamp = temp_df[1,]$Timestamp
    
    #Mutate Timestamp so that the very first value of Timestamp 
    #for patient "indPatient" and test "test" is equal to 0
    temp_df <- temp_df %>%
      mutate(Timestamp = Timestamp - initialTimestamp)
    
    #Bind temporary data frame to complete data frame
    completeDf <- rbind(completeDf, temp_df)
    
    
  }
}

kable(head(completeDf))
```

With this modification, it was easier to compare the timestamps between patients and tests, since now the first value of every test by a patient was 0.

### Calibrating the samples

A quick look at the test results (the drawings) showed that the samples were not all consistent in term of X-Y ratio (see Plot). Seven samples can be seen with a X-Y ratio of almost 2 instead of 1. With the Archimead spiral formula in mind, it seemed odd that a small part of the patients would have been given a different test with a different drawing to follow. 

```{r ploting X-Y for Test0, echo=FALSE}
#Ploting the samples for the SST by patient. It shows the different ratios in the records.
completeDf %>% 
  filter(TestID == 0) %>% 
  ggplot() +
  geom_point(aes(X,Y, color=patientID), 
             show.legend = FALSE) + 
  ggtitle("Different ratios by patient for SST samples")
```

Another odd detail was a spacial gap between patterns with the same ratio (see Plot). One of the control sample seemed to have been shifted.

```{r ploting X-Y for Test0 and controls, echo=FALSE}
#Ploting the samples for healthy controls on the SST, by patient. It shows the spatial shift between the samples
completeDf %>% 
  filter(TestID == 0 & 
           isPwp == FALSE) %>% 
  ggplot() + 
  geom_point(aes(X,Y, 
                 color=patientID), 
             show.legend = FALSE) + 
  ggtitle("Spatial gap for SST samples")
```

This disparity between the samples prevented me from trying to analyse the spacial differences between the generated Archimedean spiral and the patient's drawing. I checked if the timestamp data seemed affected or not (see Plot). It seemed as only the X and Y values were sometimes off.

```{r checking timestamps, echo=FALSE, warning=FALSE}
#Ploting (bar plot) the time needed by each patient to complete the SST. It shows that the timestamps do not seem to be affected by the material. 
completeDf %>% 
  filter(TestID == 0) %>% 
  group_by(patientID) %>% 
  summarize(maxT = max(Timestamp), 
            isPwp = first(isPwp)) %>% 
  ggplot() + 
  geom_histogram(aes(maxT, 
                     fill=isPwp), 
                 stat="bin")+ 
  ggtitle("Sample times for SST by patient")
```

To calibrate the X and Y values, the ratios $\frac{X}{Y}$ were calculated and stored in a new data frame *ratiosDf*, by patient and test. This data frame contained the ratio between X and Y as $$ratio=\frac{X_{max} - X_{min}}{Y_{max}-Y_{min}}$$

```{r calculate ratios, echo=FALSE, warning=FALSE}
#Create a dataframe 'ratiosDf' which contains the ratio X/Y (ratio), the height of the sample (H) and isPwp for each couple (patient,test)
ratiosDf <- df %>% 
  group_by(patientID, TestID) %>% 
  summarize(ratio=(max(X)-min(X))/(max(Y)-min(Y)), 
            H= max(Y)-min(Y), 
            isPwp = first(isPwp))

#Plot the ratios by test for SST and DST. It shows the gap between ratios. In the ideal case, every ratio would be of one.
ratiosDf %>% 
  filter(TestID != 2) %>% 
  ggplot() +
  geom_bar(aes(ratio, fill=TestID), stat="bin")+ 
  ggtitle("X-Y ratios")
```
We can indeed see that even if most ratios are around 1.3, some outliers are around 2. Even the initial point of the drawing was different (see next plot).

```{r starts of drawings for test 0, echo=FALSE}
#Ploting the first point of each sample (by isPwp) for the SST. It shows the spatial gap between the samples. In the ideal case, they would all be similar.
completeDf %>% 
  filter(TestID == 0 & 
           Timestamp == 0) %>% 
  ggplot() + 
  geom_point(aes(X,Y, color=isPwp))+ 
  ggtitle("Starting points for Test 0 samples")
```

To standardize all the spirals, several parameters were taken into account :
* The following ratio should be of one

$$\frac{X_{max} - X_{min}}{Y_{max}-Y_{min}}$$


* The height and length of the spiral should be the same (approximately)
* The X and Y values would have to be slid

Standardizing the ratio would simply be 
$$X_{standardized_i} = \frac{X_{old_i}}{ratio}$$ and this would imply that $$\frac{X_{maxStandardized} - X_{minStandardized}}{Y_{max}-Y_{min}}=1$$.

Resizing the height and length of the spiral would be done with : $$X_{resized_i} = \frac{X_{old_i}}{Spiral_{length}}*Size$$ and $$Y_{resized_i} = \frac{Y_{old_i}}{Spiral_{length}}*Size$$ when $Spiral_{length} = Spiral_{height}$ since the ratio $$\frac{X_{maxStandardized} - X_{minStandardized}}{Y_{max}-Y_{min}}=1$$ as seen previously, and with $Size$ is the desired size of the spiral. I chose an arbitrary $Size = 400$ and since the unit is not given I assumed it was $400px$. The unit would not matter in the study.

In order to replace the spirals near the origin of the graph ($X=0$ and $Y=0$), two adjustment parameters need to be determined. The formula would simply be $X_{slid_i}=X_{old_i}-X_{param}$ and $Y_{slid_i}=Y_{old_i}-Y_{param}$.

Several methods were tried for determining the best $X_{param}$ and $Y_{param}$ such as :

* $X_{param} = X_{mean}$ and $Y_{param} = Y_{mean}$
* $X_{param} = X_{median}$ and $Y_{param} = Y_{median}$
* $X_{param} = mean(X_{Y = Y_{median}})$ and $Y_{param} = mean(Y_{X = X_{median}})$
* $X_{param} = mean(X_{Y = Y_{mean}})$ and $Y_{param} = mean(Y_{X = X_{mean}})$
* $X_{param} = mean(X_{Y = Y_{Timestamp = 0}})$ and $Y_{param} = mean(Y_{X = X_{Timestamp = 0}})$
* $X_{param} = X_{initial}$ and $Y_{param} = Y_{initial}$

And eventually the most accurate models were :

$$X_{param} = \frac{(X_{initial} + X_{min} + X_{max})}{3}$$


$$Y_{param} = \frac{(Y_{initial} + Y_{min} + Y_{max})}{3}$$

This model took into account the assumption of which the very first values X,Y were, in general, the closest to the Archimedean Spiral when $Timestamp = 0$. $X_{min}$ and $X_{max}$ (and respectively $Y_{min}$ and $Y_{max}$) were approximations of the very tip of the drawings (see plot).

```{r modeling the Spiral and X-Y params, echo=FALSE}
#Creating an Archimedean spiral. The choice of the arguments is detailed later (see III-C Defining the Archimedean Spiral)
#b was calculated manually, t determined (the spiral is three complete turns, which means 3*2pi =6pi)
 b <- 10.61
 t <- seq(0,6*pi, length.out=1100)
 x <- b*t * (cos(t))
 y <- b*t * -(sin(t))
 
 #data frame containing the values (x,y) of the Archimedean spiral
 archimedeanSpiral = data.frame(x,y)
 
 #determined the points used to calibrate the samples. X min, max and first value, Y min and max
 points <- archimedeanSpiral %>% 
   filter(x == min(x) | 
            x == max(x) | 
            y == min(y) | 
            y == max(y) | 
            x == first(x))
 
 #Ploting the Archimedean spiral and the points used to calibrate the samples.
 archimedeanSpiral %>%
   ggplot() +
   geom_path(aes(x,y)) +
   geom_point(data = points, 
              aes(x,y),
              color="red") +
   ggtitle("Points used to slide the drawings")
```

Combining those three models gave for patient $p$, test $t$ and spiral length $L$ equal spiral height:

$$X_{i,p,t} = \frac{\frac{X_{old_i} - X_{param}}{ratio_{p,t}}}{L_{p,t}}*400 = \frac{(X_{old_i} - X_{param})*400}{ratio_{p,t}*L_{p,t}} = 400\frac{(X_{old_i} - \frac{X_{initial} + X_{min} + X_{max}}{3})}{ratio_{p,t}*L_{p,t}} $$

$$Y_{i,p,t} = \frac{Y_{old_i} - Y_{param}}{L_{p,t}}*400 = 400\frac{(Y_{old_i} - \frac{Y_{initial} + Y_{min} + Y_{max}}{3})}{L_{p,t}}$$

```{r calibrating X and Y, echo=FALSE}

#new data frame to contain the calibrated X and Y values
completeCalibratedDf <- data.frame()

#for each test
for(test in seq(0, by=1, length=2)){
  
  #for each patient
  for(indPatient in seq(1, by=1, length=nrow(patients))){
    
    #get the ratio for current patient and current test
    ratioLines <- ratiosDf %>% 
      filter(patientID == patients[indPatient,]$patientID & 
                                        TestID == test)
    
    #if the patient as taken the test (= there are values in the ratio data frame)  
    if(nrow(ratioLines) >=1){
      
      #get the ratio for current patient and current test
      ratio <- ratioLines[1,]$ratio
      
      #get the height for current patient and current test (we are standardizing X depending of Y)
      L <- ratioLines[1,]$L
      
      #get temporary data frame for current patient and current test, arranged by timestamp
      temp_df <- completeDf %>% 
        filter(TestID == test & 
                 patientID==patients[indPatient,]$patientID) %>% 
        arrange(Timestamp)
      
      #Calculate the X slid parameter
      pX <- (temp_df[which.min(temp_df$Timestamp),]$X + 
               min(temp_df$X) + 
               max(temp_df$X))/3
      
      #Calculate the Y slid parameter
      pY <- (temp_df[which.min(temp_df$Timestamp),]$Y+ 
               min(temp_df$Y) + 
               max(temp_df$Y))/3
      
      #mutate X and Y with 
      temp_df <- temp_df %>%
        mutate(X = ((X - pX)/(ratio*H))*400, 
               Y = (Y - pY)/H*400)

      #binding the already calibrated values to the ones just calibrated
      completeCalibratedDf <- rbind(completeCalibratedDf, temp_df)
    }

  }
}

#parameter to adjust (slide) the Archimedean spiral on the X axis. This will NOT be used for prediction, only for the visualization of the calibrating. That is why it is on the whole dataset (not training set).
#It is the mean of the first X for healthy patients, for SST and DST.
Xadjust <- completeCalibratedDf %>% 
  filter(TestID != 2 & 
           Timestamp==0 & 
           isPwp == FALSE) %>% 
  pull(X) %>% 
  mean()

#parameter to adjust (slide) the Archimedean spiral on the Y axis. This will NOT be used for prediction, only for the visualization of the calibrating. That is why it is on the whole dataset (not training set).
#It is the mean of the first Y for healthy patients, for SST and DST.
Yadjust <- completeCalibratedDf %>% 
  filter(TestID != 2 & 
           Timestamp==0 & 
           isPwp == FALSE) %>% 
  pull(Y) %>% 
  mean()

#Archimedean spiral adjusted (slid on X and Y with the previous adjustments parameters)
 b <- 10.61
 t <- seq(0,6*pi, length.out=1100)
 x <- b*t * (cos(t)) + Xadjust
 y <- b*t * -(sin(t)) + Yadjust
 
 #dataframe containing the X,Y values of the Archimedean spiral
 archimedeanSpiral = data.frame(x,y)

 #Ploting the calibrated samples and the slid Archimedean spiral to show the improvement in the samples. They are now more consistent.
completeCalibratedDf %>% 
  filter(TestID == 0) %>% 
  ggplot() + 
  geom_point(aes(X,Y, 
                 color=patientID), 
             show.legend = FALSE) + 
  ggtitle("Calibrated samples for SST and DST") + 
  geom_point(data=archimedeanSpiral, aes(x,y), color="red")

```


## Data analysis

This section describes the analysis of the different tests in the dataset. Since there was no prediction here, and some additionnal information (calculated and determined values) were to be noted in the `patients` data frame, the analysis was performed on the whole datas.

### Global analysis

The very first point to stress out was that every patient did not perform the three tests.

```{r tests taken, echo=FALSE, warning=FALSE}
#Ploting the number of each test taken. It shows that not every patient took all the tests.
ratiosDf %>% 
  ggplot() + 
  geom_histogram(aes(TestID, 
                     fill=isPwp),
                 stat="count")+
  ggtitle("Tests taken")
```

This would probably alter the accuracy of the future predictions. The original study based its analysis on the combination of SST and DST, and though every patient took the SST (Static Spiral Test), some DST (Dynamic Spiral Test) were missing from the dataset. This issue is detailed and handled on section IV-A Test inconsistency.

### Creating training and testing sets

In order to calibrate the Archimedean spiral, I needed to create training and testing sets. Since we had very little values, I needed to make sure I had control patients in both sets, as well as patients (control and not) who had taken the Stability on Certain Point Test.
I created several sub-datasets as :

* `subControls` : a dataset with only control patients, who had not taken the Stability on Certain Point Test
* `subParkinsons`: a dataset with only patients with the Parkinson's disease, who had not taken the Stability on Certain Point Test
* `subTest2Ctrl` : a dataset with only control patients who had taken the Stability on Certain Point Test
* `subTest2Parkinsons` : a dataset with only patients with the Parkinson's disease, who had taken the Stability on Certain Point Test

```{r building subsets, include=FALSE}
#Data frame containing the unique couples patient/test. It will allow me to split the datas into the four datasets I need to create training and testings sets with every cases (controls, patients/SOCPT and SST-DST)
groupedPatientTestDf <- df %>% 
  group_by(patientID, TestID) %>% 
  select(patientID, TestID, isPwp) %>% 
  unique()

#data frame with healthy controls who took the SOCPT
subTest2Ctrl <- groupedPatientTestDf %>% 
  filter(TestID == 2 & 
           isPwp==FALSE) %>% 
  ungroup() %>% 
  select(patientID) %>% 
  unique()

#data frame with people with Parkinson's who took the SOCPT
subTest2Parkinsons  <- groupedPatientTestDf %>% 
  filter(TestID == 2 & 
           isPwp==TRUE) %>% 
  ungroup() %>% 
  select(patientID) %>% 
  unique()

#data frame with healthy controls who did not took the SOCPT
subControls <- groupedPatientTestDf %>% 
  filter(isPwp==FALSE & 
           !patientID %in% subTest2Ctrl$patientID) %>% 
  ungroup() %>% 
  select(patientID) %>% 
  unique()

#data frame with people with Parkinson's who did not took the SOCPT
subParkinsons <- groupedPatientTestDf %>% 
  filter(isPwp==TRUE & 
           !patientID %in% subTest2Parkinsons$patientID) %>% 
  ungroup() %>% 
  select(patientID) %>% 
  unique()

#checking if the number of patients in each data frame is consistent with the total number of patients
nrow(subTest2Ctrl) + 
  nrow(subTest2Parkinsons) + 
  nrow(subControls) +
  nrow(subParkinsons) == nrow(patients)

#Getting random samples for each sub-data set
testIndexT2Ctrl <- sample(1:nrow(subTest2Ctrl), 
                          floor(nrow(subTest2Ctrl)*0.1)+1) 

testIndexT2Parkinsons <- sample(1:nrow(subTest2Parkinsons), 
                                floor(nrow(subTest2Parkinsons)*0.1)+1) 

testIndexCtrl <- sample(1:nrow(subControls), 
                        floor(nrow(subControls)*0.1)+1) 

testIndexParkinsons <- sample(1:nrow(subParkinsons), 
                              floor(nrow(subParkinsons)*0.1)+1) 

#binding the sample patient ids from each sub-data set in a testing data set
testing_patients <- subTest2Ctrl[testIndexT2Ctrl,]

testing_patients <- rbind(testing_patients, 
                          subTest2Parkinsons[testIndexT2Parkinsons,])

testing_patients <- rbind(testing_patients, 
                          subControls[testIndexCtrl,])

testing_patients <- rbind(testing_patients, 
                          subParkinsons[testIndexParkinsons,])

#creating the testing dataset with all columns from the data frame patients
testingSet <- patients %>% 
  filter(patientID %in% testing_patients$patientID)

#creating the training dataset with all columns from the data frame patients
trainingSet <- patients %>% 
  filter(!patientID %in% testing_patients$patientID)
```

This method was way less simple than the `createDataPartition` function, but allowed me to get a sample of each case in both training and testing sets.

### Defining the Archimedean spiral

The equation of the Archimedean spiral can be described with :
$$\left\{
    \begin{array}{l}
      x(t)= a + bt*cos(t)\\
      y(t)= a + bt*sin(t)
    \end{array}
  \right.$$
  
I defined $a = 0$ and determined that the spiral ranged from $0$ (the origin of the spiral) to $6\pi$ (the last point of the spiral). This meant that the spiral did three complete turns. I had to make a slight modification so the Archimedean spiral would match the drawings, as :

$$\left\{
    \begin{array}{l}
      x(t)= a + bt*cos(-t) = a + bt*cos(t)\\
      y(t)= a + bt*sin(-t)=a - bt*sin(t)
    \end{array}
  \right.$$
  
I fixed the maximum size of the spiral to 200 (see II-C, Calibrating the samples), so I had the equation :

$$\left\{
    \begin{array}{l}
      x(t_{max}=6\pi)= bt*cos(6\pi) = bt = b*6\pi = 200\\
      y(t_{max})= - bt*sin(6\pi) = 0
    \end{array}
  \right.$$
  
Which meant that $b=\frac{200}{6\pi} \approx 10.61$. I also needed to slide the spiral, with $x_{adjust} = \overline{x(t=0, isPwp = FALSE)}$ and $y_{adjust}= \overline{x(t=0, isPwp = FALSE)}$ so that it was overlapping the drawings. The equation was then :

$$\left\{
    \begin{array}{l}
      x(t)= 10.61 *t*cos(t) + x_{adjust}\\
      y(t)= -10.61*t*sin(t) + y_{adjust}
    \end{array}
  \right.$$

### Distance (Static and Dynamic Spiral) analysis

I built a method which would estimate the difference between the Archimedean Spiral and the patient's drawing to be used for the analysis of the first two tests, using the `rgeos` package and the notion of `Spatial points` to work with spatial coordinates.

The logic behind the algorithm was quite simple. I defined four variables in the `patients` dataframe, `areaT0` (the area between the drawing of the SST and the Archimedean spiral),  `areaT1` (the area between the drawing of the DST and the Archimedean spiral), `sdT0` (the standard deviation between the SST and the Archimedean spiral), `sdT1` (the standard deviation between the DST and the Archimedean spiral). For each unique point on the drawing (SST and DST), I determined the closest point on the Archimedean spiral using `gDistance` of the `rgeos` package and `which.min`. I then calculated the distance using :
$$d_i = \sqrt{(x_{test}-x_{spiral})^2 + (y_{test}-y_{spiral})^2}$$
With $d_i$ the distance of the point $i =(x_{test}, y_{test})$ of the drawing and it's closest point on the Archimedean spiral $(x_{spiral},y_{spiral})$. The area between the drawing and the spiral was approximated by :
$$A_{T_i} = \sum_i{d_i}$$

```{r calculating distance between Archimedean Spiral and drawing0, echo=FALSE, message=FALSE, warning=FALSE}

#Initialisation of the values : 
#total area difference between the drawing 
#and the Archimedean spiral, 
#and the standard deviation of the distance 
#between the drawing and the spiral.
patients <- patients %>% mutate(areaT0 = NA, 
                                areaT1 = NA, 
                                sdT0 = NA, 
                                sdT1 = NA)

#calibrating the Archimedean spiral 
#with first X value of SST 
#and DST from healthy controls
#in the testing data set
Xadjust <- completeCalibratedDf %>% 
  filter(TestID != 2 & 
           Timestamp==0 & 
           patientID %in% trainingSet$patientID &
           isPwp == FALSE) %>% 
  pull(X) %>% 
  mean()

#calibrating the Archimedean spiral 
#with first Y value of SST 
#and DST from healthy controls
#in the testing data set
Yadjust <- completeCalibratedDf %>% 
  filter(TestID != 2 & 
           Timestamp==0 & 
           patientID %in% trainingSet$patientID &
           isPwp == FALSE) %>% 
  pull(Y) %>% 
  mean()

#The calculus is applied to the first two tests (Static and Dynamic Spiral test)
for(test in seq(0, by=1, length=2)){
  
  #For every patient in the data set
  for(p in seq(1, by=1, length=nrow(patients))){
    
    #Defining current patient
    patient = patients[p,]$patientID
    
    #Select every unique couple X,Y for current patient on current test
    temp_df <- completeCalibratedDf %>% 
      filter(TestID==test & 
               patientID == patient) %>% 
      select(X,Y) %>% 
      unique()
    
    #if there are values (= if the patient has taken the test)
    if(nrow(temp_df)>0){
      
       #construct the archimedeanSpiral
       b <- 10.61
       t <- seq(0,6*pi, length.out=nrow(temp_df))
       x <- b*t * (cos(t)) + Xadjust
       y <- b*t * -(sin(t)) + Yadjust
       
       #build a data frame for the archimedean spiral coordinates
       archimedeanSpiral = data.frame(x,y)
       
       #add row number for further left_join
       archimedeanSpiral <- archimedeanSpiral %>% 
         mutate(nr=row_number())
      
      #Convert data frames in spatial points (rgeos package) 
      temp_df_sp <- SpatialPoints(temp_df)
      sp <- SpatialPoints(archimedeanSpiral)
      
      #calculate minimum distance between the drawing and the spiral
      temp_df$nr <- apply(gDistance(temp_df_sp, sp, byid=TRUE), 1, which.min)
      
      temp_df <- left_join(temp_df, archimedeanSpiral, by="nr")
      
      temp_df <- temp_df %>% mutate(dist = sqrt((X-x)^2+(Y-y)^2)) %>% select(X,Y,dist)
      
      patients[p,][paste0("areaT", test)] <- sum(temp_df$dist)
      patients[p,][paste0("sdT",test)] <- sd(temp_df$dist)
    }
  
  }
}
plotComparingTestsWithArchimedeanSpiral <- patients %>% ggplot()

plotT0Archi <- plotComparingTestsWithArchimedeanSpiral + 
  geom_histogram(aes(areaT0, fill=isPwp, color=patientID), stat="bin") 

plotT1Archi <- plotComparingTestsWithArchimedeanSpiral + 
  geom_histogram(aes(areaT1, fill=isPwp, color=patientID), stat="bin") 

plotSdT0Archi <- plotComparingTestsWithArchimedeanSpiral + 
  geom_histogram(aes(sdT0, fill=isPwp, color=patientID), stat="bin") 

plotSdT1Archi <- plotComparingTestsWithArchimedeanSpiral + 
  geom_histogram(aes(sdT1, fill=isPwp, color=patientID), stat="bin") 

ggarrange(plotT0Archi, 
          plotT1Archi, 
          plotSdT0Archi,
          plotSdT1Archi, ncol=2, nrow=2, common.legend = TRUE)

```

This approach did not seem very conclusive. Even if the results of the healthy patient were close, many patients with Parkinson's disease had similar results. It seemed more appropriate to compare instead the drawings of the first two tests and to compute their area difference (`areaT0_T1`), and standard deviation (`sdT0_T1`). I also computed the time difference (`difft1_t0`) between those two tests. The algorithm was similar to the one used for the comparison of the drawings and the Archimedean spiral.

For each unique point on the SST drawing, I determined the closest point on the DST drawing using `gDistance` of the `rgeos` package and `which.min`. I then calculated the distance using :
$$d_i = \sqrt{(x_{SST}-x_{DST})^2 + (y_{SST}-y_{DST})^2}$$
With $d_i$ the distance of the point $i =(x_{SST}, y_{SST})$ of the SST drawing and it's closest point on the DST drawing $(x_{DST},y_{DST})$. The area between the drawing and the spiral was approximated by :
$$A_{T_i} = \sum_i{d_i}$$

The time difference was :
$$\Delta = t_{DSTmax} - t_{SSTmax}$$
```{r calculating distance between Test 0 and Test 1, echo=FALSE, message=FALSE, warning=FALSE}

#Initialisation of the values : 
#total area difference between the drawing and the Archimedean spiral, 
#and the standard deviation of the distance between the drawing and the spiral.
patients <- patients %>% mutate(areaT0_T1 = NA, sdT0_T1 = NA)

  #For every patient in the data set
  for(p in seq(1, by=1, length=nrow(patients))){
    
    #Defining current patient
    patient = patients[p,]$patientID
    
    #Select every unique couple X,Y for current patient on test 0
    temp_df0 <- completeCalibratedDf %>% 
      filter(TestID==0 & 
               patientID == patient) %>% 
      select(X,Y) %>% 
      unique() %>% 
      mutate(nr=row_number())
    
    #Select every unique couple X,Y for current patient on test 1
    temp_df1 <- completeCalibratedDf %>% 
      filter(TestID==1 & 
               patientID == patient) %>% 
      select(X,Y) %>% 
      unique() %>% 
      mutate(nr=row_number())
    
    #if there are values (= if the patient has taken the test)
    if(nrow(temp_df0)>0 & nrow(temp_df1)>0){
      
      #Convert data frames in spatial points (rgeos package) 
      temp_df0_sp <- SpatialPoints(temp_df0)
      temp_df1_sp <- SpatialPoints(temp_df1)

        temp_df1$nr <- apply(gDistance(temp_df0_sp, temp_df1_sp, byid=TRUE), 1, which.min)
        
        temp_df <- inner_join(temp_df1, temp_df0, by="nr")
      
      
      
      temp_df <- temp_df %>% 
        mutate(dist = sqrt((X.x-X.y)^2+(Y.x-Y.y)^2)) %>% 
        select(X.x,Y.y,dist)
      
      patients[p,]$areaT0_T1 <- sum(temp_df$dist)
      patients[p,]$sdT0_T1 <- sd(temp_df$dist)
    }
  
  
  }

times0 <- completeCalibratedDf %>% 
  filter(TestID == 0 & 
           Z == 0) %>% 
  group_by(patientID) %>% 
  summarize(time0 = max(Timestamp))

times1 <- completeCalibratedDf %>% 
  filter(TestID == 1 & 
           Z == 0) %>% 
  group_by(patientID) %>% 
  summarize(time1 = max(Timestamp))

times <- left_join(times0, times1, by="patientID")

times <- times %>% 
  mutate(difft1_t0 = time1 - time0) %>% 
  select(difft1_t0, patientID)

patients <- left_join(patients, times, by="patientID")

plotT0_T1 <- patients %>% ggplot() 

plotAreaT0_T1 <- plotT0_T1 + 
  geom_histogram(aes(areaT0_T1, fill=isPwp, color=patientID), stat="bin") 

plotSdT0_T1 <- plotT0_T1 + 
  geom_histogram(aes(sdT0_T1, fill=isPwp, color=patientID), stat="bin")

plotDiffTimesT0_T1 <- plotT0_T1 + 
  geom_histogram(aes(difft1_t0, fill=isPwp, color=patientID), stat="bin")

ggarrange(plotAreaT0_T1,
          plotSdT0_T1, 
          plotDiffTimesT0_T1, ncol=2, nrow=2, common.legend = TRUE)

```

With this method, comparing the Static Spiral Test and the Dynamic Spiral Test, it was easier to categorize the patients. The results were more distinct.

### Stability Test on Certain Point analysis

This test would give important information about the hand tremor of the patient. If the pen was to touch the screen, or move a lot over the tablet, the patient would probably have the Parkinson's disease. To quantify this, I computed the number of points on the screen (basically every point where Z equal to 0) and the total distance on the X and Y axis of the pen. The distance between two points was :

$$d_i = \sqrt{(x_i-x_{i-1})^2+(y_i-y_{i-1})^2}$$
The total distance of the pen over the tablet was :

$$D = \sum_i{d_i}$$
```{r computing values for Test2, echo=FALSE, warning=FALSE}
patients <- patients %>% mutate(Z0_T2 = NA, DistT2 = NA)

 for(index in seq(1, by=1, length=nrow(patients))){
      
      id <- patients[index,]$patientID
      
      temp <- completeDf %>% 
        filter(patientID == id & TestID == 2) %>%
        arrange(Timestamp) %>% select(X,Y,Z)
      
      if(nrow(temp)>0){
        
        patients[index,]$Z0_T2 <- nrow(temp %>% filter(Z == 0))
        
        temp <- temp %>% select(X,Y) %>% unique()
        dist <-0
        for(row in seq(2, by=1, length= nrow(temp)-1)){
          dist <- dist + sqrt((temp[row,]$X - temp[row-1,]$X)^2+(temp[row,]$Y - temp[row-1,]$Y)^2)
        }
        patients[index,]$DistT2 <- dist
      }
    }

```

## Issues

### Tests inconsistency

The very first issue was that every patient did not take the three tests. I needed then to come up with algorithms managing the different cases.

```{r analysing different cases}
couplesTestsPatients <- df %>% 
  select(patientID,TestID) %>% 
  group_by(patientID, TestID) %>% unique()

PatientsT0 <- couplesTestsPatients %>% 
  filter(TestID == 0)

PatientsT1 <- couplesTestsPatients %>% 
  filter(TestID == 1)

PatientsT2 <- couplesTestsPatients %>% 
  filter(TestID == 2)

#Are there any patients who took the SST 
#but neither the DST nor the SOCP?
PatientsT0 %>% 
  filter(!patientID %in% PatientsT1$patientID & 
           !patientID %in% PatientsT2$patientID) %>% 
  nrow() > 0

#Are there any patients who took the SST 
#and the DST but not the SOCP?
PatientsT0 %>% 
  filter(patientID %in% PatientsT1$patientID & 
           !patientID %in% PatientsT2$patientID) %>% 
  nrow() > 0

#Are there any patients who took the SST 
#and the SOCP but not the DST?
PatientsT0 %>% 
  filter(!patientID %in% PatientsT1$patientID & 
           patientID %in% PatientsT2$patientID) %>% 
  nrow() > 0

#Are there any patients who took the SST, DST and SOCP ?
PatientsT0 %>% 
  filter(patientID %in% PatientsT1$patientID & 
           patientID %in% PatientsT2$patientID) %>% 
  nrow() > 0


#Are there any patients who took the DST 
#but neither the SST nor the SOCPI?
PatientsT1 %>% 
  filter(!patientID %in% PatientsT0$patientID & 
           !patientID %in% PatientsT2$patientID) %>% 
  nrow() > 0

#Are there any patients who took the DST 
#and the SOCP but not the SST?
PatientsT1 %>% 
  filter(patientID %in% PatientsT2$patientID & 
           !patientID %in% PatientsT0$patientID) %>% 
  nrow() > 0
PatientsT2 %>% 
  filter(patientID %in% PatientsT1$patientID & 
           !patientID %in% PatientsT0$patientID) %>% 
  nrow() > 0

#Are there any patients who took the SOCP 
#but neither the SST nor the DST?
PatientsT2 %>% 
  filter(!patientID %in% PatientsT0$patientID & 
           !patientID %in% PatientsT1$patientID) %>% nrow() > 0
```

Thoses four different cases were, patients who :

* Took the Static Spiral Test and only one of the other test (Dynamic Spiral Test or Stability On Certain Point Test)
* Took all three tests
* Took only the Stability On Certain Point Test

### Material inconsistency

As seen in the Data Cleaning - Calibrating the samples section, the records were not on the same scale and sometimes not on the same starting point.

### Missing software and informations

Another issue was that I had no access to the software used to record the tests, nor to the configuration of the Archimedean spiral used for the tests. I did not have the frequency at which the SST blinked. My study and models were therefore limited. 

## Prediction algorithms

In this section I defined the predition models and different algorithms.

### Final prediction model

Based on the previous observations I defined independant predictions as :

* Prediction on the Static Spiral Test compared to the Dynamic Spiral Test ($\hat{Y}_{SST\sim DST}$)
* Prediction on the Stability On Certain Point Test ($\hat{Y}_{SOCPT}$)

When it was not possible to do the prediction due to the tests recorded, the value would be `NA`. I did a weighted average, figuring that the prediction on the Stability On Certain Point Test was more precise than the prediction on the Static Spiral Test compared to the Dynamic Spiral Test, and that this last one was more precise thant the prediction on the Static Spiral Test compared to the Archimedean Spiral as :

$$\hat{Y} = \overline{\hat{Y}_{SST\sim DST} + 4*\hat{Y}_{SOCPT}}$$
When there was a missing missing predictions, they were removed from the equation.

### Chosing the prediction algorithms

I picked the random forest model (`randomForest`). The k-nearest neighboors and the linear regression were not approriate for the data gathered and computed. I would then do the mean between the two predictions.

The model would become :

$$\hat{Y} = \overline{{\hat{Y}_{SST\sim DST, rf}}+ 4*\hat{Y}_{SOCPT,rf}}$$

### Completing the training and testing sets

In order to use all the parameters calculated and computed, I needed to merge the training and testing set with the complete `patients` data frame. This would allow me to not create testing and training sets again with the complete datas.

```{r completing training and testing sets}
trainingSet <- left_join(trainingSet, patients %>% 
                           select(-isPwp), by="patientID")
testingSet <- left_join(testingSet, patients %>% 
                          select(-isPwp), by="patientID")
```

### Parameters

The variables used for each prediction model were :

* Static Spiral Test compared to the Dynamic Spiral Test ($\hat{Y}_{SST\sim DST}$) : area difference between the test 0 and the test 1 (`sdT0_T1`), its standard deviation ( `sdT0_T1`) and the difference of execution time between the two tests (`difft1_t0`)
* Stability On Certain Point Test ($\hat{Y}_{SOCPT}$) : the number of points where the pen touched the screen (`Z0_T2`) and the total distance on the plan (`X`,`Y`) of the pen (`DistT2`)

It was required to mutate `isPwp` to be a numeric instead of a boolean.

```{r parsing isPwp to numeric, include=FALSE}
trainingSet <- trainingSet %>% 
  mutate(isPwp = as.numeric(isPwp))

testingSet <- testingSet %>% 
  mutate(isPwp = as.numeric(isPwp))
```

### Fitting models

It was time to define the six fitting models and compute the different predictions:

```{r fitting models, warning=FALSE}
#Static Spiral Test compared to the Dynamic Spiral Test
#random forest
fit_SST_DST <- randomForest(isPwp ~ areaT0_T1 + 
                              sdT0_T1 + 
                              difft1_t0,
                               data=trainingSet, 
                            na.action = na.omit)

yhat_SST_DST <- predict(fit_SST_DST, 
                        testingSet)


#Stability On Certain Point Test
#random forest
fit_SOCPT <- randomForest(isPwp ~ Z0_T2 + 
                            DistT2, 
                             data=trainingSet, 
                          na.action=na.omit)

yhat_SOCPT <- predict(fit_SOCPT, 
                      testingSet)


#Computing the predictions
yhatDf <- data.frame(yhat_SST_DST,
                     yhat_SOCPT)

p_hat <- yhatDf %>% 
  rowwise() %>% 
  mutate(phat = weighted.mean(c(yhat_SST_DST,
                                yhat_SOCPT), 
                              c(1,4), 
                              na.rm=TRUE)) %>% 
  select(phat)
```

# Results

The accuracy we got with this model was of one, the perfect accuracy. There was no need to improve the algorithm more. But, it should be treated cautiously. Since we do not have much data in the dataset, we have no certainty about the accuracy for the people with the disease at it's very first stage. It is also complicated to apprehend since we do not have access to the medical "score" for each patient, instead we have a binary result, healthy, or with Parkinson's. In the ideal scenario, we would have had access to a scale, with the "progress" of the disease (which stage at least).
```{r results}
Yhat <- ifelse(p_hat >0.5, 1, 0) %>% 
  factor()

p_hat

confusionMatrix(Yhat, 
                testingSet$isPwp %>% 
                  factor())$overall["Accuracy"]
```


# Conclusion

The original study shows that it is possible to acquire handwriting tests and monitor Parkinson's disease with a digital tablet, using mostly the difference of acceleration for the Static Spiral drawing and the Dynamic Spiral drawing. I showed here that it was also possible to compute the area difference between those two tests, as well as the distance traveled by the pen on the Stability On Certain Point test, and that feeding these results in a random forest algorithm could predict accurately if the patient had or not Parkinson's disease. These tests could be used to determine if a patient should proceed with the medical tests and consult a specialist, without having to go to an hospital and get the invasive neurological tests (if not needed). When using `phat` (the prediction of the random forest algorithms), it could be possible to monitor the advancement of the disease. 

I believe that with more consistent datas and more information (and possibly more records), it is possible to meliorate the algorithm, and be more precise and accurate in the predictions and monitoring.


# Sources and references

Brain anatomy : https://en.wikipedia.org/wiki/Midbrain

Definitions : https://www.yourdictionary.com

Dopamine : https://en.wikipedia.org/wiki/Dopamine

Neurotransmitter : https://en.wikipedia.org/wiki/Neurotransmitter

Parkinson's disease : https://en.wikipedia.org/wiki/Parkinson%27s_disease

Substantia nigra : https://en.wikipedia.org/wiki/Substantia_nigra


